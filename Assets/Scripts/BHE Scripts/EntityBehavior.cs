using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class EntityBehaviour : ScriptableObject
{
    //The difference between these two vars is that Type is used for all prefabs of an behavior, i.e. Rotate_Behavior, while Name is used for individual setups, i.e. Rotate_45_Clockwise_Behavior
    //Type is designed for other behaviors to grab this one, even if the values are different (i.e. an behavior can grab a Rotate_Behavior whether it's Rotate_45_Clockwise or Rotate_15_CounterClockwise)
    //Name is used by the object pooler to grab specific prefabs of behaviors


    //A tag for the type of entity behavior it is. Used so other behaviors can locate this one. Should not be changed after caching
    [HideInInspector]
    public const string EntityBehaviorType = "DEFAULT_PROJECTILE_EFFECT_TYPE";
    public virtual string GetEntityBehaviorType() => EntityBehaviorType;

    [Header("Base Vars")]
    //The key for this specific setup of the entity behavior. Should never be changed after being cached in CachedBHEResources
    public string EntityBehaviorName = "DEFAULT_PROJECTILE_EFFECT_NAME";



    //Prevents the component from being removed from a entity when that entity's Disable() is called
    //WARNING: behaviors are allowed to be added to the same entity multiple times. this may result in unexpected behavior such as entities moving twice as far in one step
    //          I recommend avoiding this altogether
    public bool isPermanent = false;
    /// <summary> 
    /// Determines if this behavior should be passed to spawners generated by the attached entity
    /// 
    /// Examples of behaviors to not pass to children: entity splitting behaviors (infinite entities is bad!)
    /// 
    /// A value of -1 will pass the behavior every time (logic is: inherit when != 0)
    /// This needs to be decremented every time a entity adds a new copy of the behavior TO a SPAWNER, not from the spawner when added to a entity or anywhere else
    /// </summary>
    public int generationsToInheritBehavior = -1;
    protected bool hasAppliedBehaviors = false;
    protected bool hasAppliedLateBehaviors = false;

    //Used to reset variables on an instance of an behavior
    public virtual void Init()
    {
        hasAppliedBehaviors = false;
    }

    //Copy is used for values changed after initialization relative to a specific copy of the behavior (i.e an behavior that contains a list of objects in the scene)
    public virtual void Copy(EntityBehaviour oldBehavior)
    {
        //entityBehaviorType = oldBehavior.entityBehaviorType;
        //entityBehaviorName = oldBehavior.entityBehaviorName;

        isPermanent = oldBehavior.isPermanent;

        generationsToInheritBehavior = oldBehavior.generationsToInheritBehavior;

        hasAppliedBehaviors = false;
        hasAppliedLateBehaviors = false;
    }

    //Assigns behaviors to the correct places in
    //'s sequence of events
    public virtual void AddBehaviors(Entity entity)
    {
        if (!hasAppliedBehaviors)
        {
            //Apply Behaviors
            //Debug.Log("Applying Behaviors!");
            hasAppliedBehaviors = true;
        }
    }

    //For behaviors that synergize / work with other behaviors
    public virtual void LateAddBehaviors(Entity entity)
    {
        if (!hasAppliedLateBehaviors)
        {
            //Apply late behaviors
        }

        hasAppliedLateBehaviors = true;
    }

    //For behaviors when a new behavior is added via an outside actor after LateAddBehaviors
    public virtual void UpdateBehaviors(Entity entity)
    {

    }

    //Removes the behaviors assigned in AddBehaviors()
    public virtual void RemoveBehaviors(Entity entity)
    {
        if (isPermanent)
        {
            //Debug.Log("Permanent behavior, not removing");
            return;
        }
        else
        {
            hasAppliedBehaviors = false;
            hasAppliedLateBehaviors = false;
        }
    }

    //TODO: figure this out lol I really want lasers
    public virtual T ConvertToLaserBehavior<T>()
    {
        return default(T);
    }
}
